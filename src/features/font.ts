/**
 * fontManager生成的字体轮廓与fontEditor中的字体组件相互转换方法
 */
/**
 * convertor for contours generated by fontManager to components defined in fontEditor
 */

import { PathType } from '../fontManager'
import type {
	ILine,
	ICubicBezierCurve,
	IQuadraticBezierCurve,
} from '../fontManager'
import { genPenComponent } from '../fontEditor/tools/pen'
import type { IComponent, Component } from '../fontEditor/stores/files'
import { type IPoint as IPenPoint } from '../fontEditor/stores/pen'
import type { IPenComponent } from '../fontEditor/stores/files'
import { modifyComponentForCharacterFile, type IPolygonComponent, type IRectangleComponent } from '../fontEditor/stores/files'
import type { IEllipseComponent } from '../fontEditor/stores/files'
import { fitCurve, type IPoint } from '../features/fitCurve'
import { getEllipsePoints, getRectanglePoints, transformPoints } from '../utils/math'
import { genUUID } from '../utils/string'
import { width } from '../fontEditor/stores/global'
import { ICustomGlyph, IGlyphComponent, executeScript, modifyComponentForGlyph } from '../fontEditor/stores/glyph'
import { EllipseComponent } from '../fontEditor/programming/EllipseComponent'
import { RectangleComponent } from '../fontEditor/programming/RectangleComponent'
import { PenComponent } from '../fontEditor/programming/PenComponent'
import { PolygonComponent } from '../fontEditor/programming/PolygonComponent'
import * as R from 'ramda'
import { linkComponentsForJoints } from '../fontEditor/programming/Joint'
import { computeCoords } from '../fontEditor/canvas/canvas'

const contoursToComponents = (contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
}) => {
	const components = contours.map((contour) => {
		const points: Array<IPenPoint> = []
		for (let i = 0; i < contour.length; i++) {
			const path = contour[i]
			if (i === 0) {
				points.push({
					uuid: genUUID(),
					x: path.start.x,
					y: path.start.y,
					type: 'anchor',
					origin: null,
					isShow: true,
				})
			}
			switch (path.type) {
				case PathType.LINE: {
					const control1 = {
						uuid: genUUID(),
						x: path.start.x,
						y: path.start.y,
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genUUID(),
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genUUID(),
						x: path.end.x,
						y: path.end.y,
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
				case PathType.QUADRATIC_BEZIER: {
					const control1 = {
						uuid: genUUID(),
						x: path.start.x + 2 / 3 * (path.control.x - path.start.x),
						y: path.start.y + 2 / 3 * (path.control.y - path.start.y),
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genUUID(),
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genUUID(),
						x: path.end.x + 2 / 3 * (path.control.x - path.end.x),
						y: path.end.y + 2 / 3 * (path.control.y - path.end.y),
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
				case PathType.CUBIC_BEZIER: {
					const control1 = {
						uuid: genUUID(),
						x: path.control1.x,
						y: path.control1.y,
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genUUID(),
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genUUID(),
						x: path.control2.x,
						y: path.control2.y,
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
			}
		}
		if (points.length && (points[points.length - 1].x !== points[0].x || points[points.length - 1].x !== points[0].y)) {
			points.push({
				uuid: genUUID(),
				x: points[points.length - 1].x,
				y: points[points.length - 1].y,
				type: 'control',
				origin: points[points.length - 1].uuid,
				isShow: true,
			})
			points.push({
				uuid: genUUID(),
				x: points[0].x,
				y: points[0].y,
				type: 'control',
				origin: points[0].uuid,
				isShow: true,
			})
			points.push({
				uuid: genUUID(),
				x: points[0].x,
				y: points[0].y,
				type: 'anchor',
				origin: points[0].uuid,
				isShow: true,
			})
		}
		return genPenComponent(formatPoints(points, options, 0) as Array<IPenPoint>, true) as unknown as IComponent
	})
	return components
}

const formatPoints = (points: Array<IPenPoint | IPoint>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
}, type: number) => {
	const { unitsPerEm, descender, advanceWidth } = options
	if (type === 0) {
		const scale = 1//width.value / unitsPerEm
		return points.map((point) => {
			let x = point.x + (unitsPerEm - advanceWidth) / 2
			//let y = point.y + unitsPerEm - ascender
			let y = unitsPerEm - point.y
			y = y + descender
			x *= scale
			y *= scale
			return {
				...point,
				x, y
			}
		})
	} else if (type === 1) {
		const scale = 1//unitsPerEm / width.value
		return points.map((point) => {
			let x = point.x * scale
			let y = point.y * scale
			x -= (unitsPerEm - advanceWidth) / 2
			y = y - descender
			y = unitsPerEm - y
			return {
				...point,
				x, y
			}
		})
	}
	return points
}

type _Component = Component | EllipseComponent | RectangleComponent | PenComponent | PolygonComponent

const componentsToContours = (components: Array<_Component>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
	grid?: any,
}, offset: {
	x: number,
	y: number,
} = { x: 0, y: 0 }, isGlyph: boolean = false, preview: boolean = true, forceUpdate: boolean = false) => {
	//-------
	// forceUpdate = true
	//-------
	let contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>> = []
	components.map((component) => {
		if (!component.usedInCharacter) return
		let { x, y, w, h, rotation, flipX, flipY } = component as IComponent
		//x && (x += offset.x)
		//y && (y += offset.y)
		switch (component.type) {
			case 'pen': {
				if (!((component as Component).value as unknown as IPenComponent).contour || forceUpdate) {
					let transformed_points = transformPoints(((component as Component).value as unknown as IPenComponent).points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					if (options.grid) {
						transformed_points = transformed_points.map((point) => {
							return computeCoords(options.grid, point)
						})
					}
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genPenContour(contour_points)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genPenContour(preview_points);

					((component as Component).value as unknown as IPenComponent).preview = preview_contour;
					((component as Component).value as unknown as IPenComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IPenComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IPenComponent).preview)
				}
				break
			}
			case 'polygon': {
				if (!((component as Component).value as unknown as IPolygonComponent).contour || forceUpdate) {
					let transformed_points = transformPoints(((component as Component).value as unknown as IPolygonComponent).points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					if (options.grid) {
						transformed_points = transformed_points.map((point) => {
							return computeCoords(options.grid, point)
						})
					}
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genPolygonContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genPolygonContour(preview_points);

					((component as Component).value as unknown as IPolygonComponent).preview = preview_contour;
					((component as Component).value as unknown as IPolygonComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IPolygonComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IPolygonComponent).preview)
				}
				break
			}
			case 'rectangle': {
				if (!((component as Component).value as unknown as IRectangleComponent).contour || forceUpdate) {
					const rect = (component as Component).value as unknown as IRectangleComponent
					let transformed_points = transformPoints(getRectanglePoints(
						rect.width,
						rect.height,
						(component as IComponent).x,
						(component as IComponent).y,
					), {
						x, y, w, h, rotation, flipX, flipY,
					})
					if (options.grid) {
						transformed_points = transformed_points.map((point) => {
							return computeCoords(options.grid, point)
						})
					}
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genRectangleContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genRectangleContour(preview_points);

					((component as Component).value as unknown as IRectangleComponent).preview = preview_contour;
					((component as Component).value as unknown as IRectangleComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IRectangleComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IRectangleComponent).preview)
				}
				break
			}
			case 'ellipse': {
				if (!((component as Component).value as unknown as IRectangleComponent).contour || forceUpdate) {
					const ellipse = (component as Component).value as unknown as IEllipseComponent
					let points = getEllipsePoints(
						ellipse.radiusX,
						ellipse.radiusY,
						1000,
						(component as IComponent).x + ellipse.radiusX,
						(component as IComponent).y + ellipse.radiusY,
					)
					let transformed_points = transformPoints(points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					if (options.grid) {
						transformed_points = transformed_points.map((point) => {
							return computeCoords(options.grid, point)
						})
					}
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genEllipseContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genEllipseContour(preview_points);

					((component as Component).value as unknown as IRectangleComponent).preview = preview_contour;
					((component as Component).value as unknown as IRectangleComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IRectangleComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IRectangleComponent).preview)
				}
				break
			}
			case 'glyph-pen': {
				if (!(component as PenComponent).contour || !(component as PenComponent).contour.length || forceUpdate) {
					(component as PenComponent).updateData(isGlyph, options.grid)
				}
				if (!preview) {
					contours.push((component as PenComponent).contour)
				} else {
					contours.push((component as PenComponent).preview)
				}
				break
			}
			case 'glyph-polygon': {
				if (!(component as PolygonComponent).contour || !(component as PolygonComponent).contour.length || forceUpdate) {
					(component as PolygonComponent).updateData(isGlyph)
				}
				if (!preview) {
					contours.push((component as PolygonComponent).contour)
				} else {
					contours.push((component as PolygonComponent).preview)
				}
				break
			}
			case 'glyph-rectangle': {
				if (!(component as RectangleComponent).contour || !(component as RectangleComponent).contour.length || forceUpdate) {
					(component as RectangleComponent).updateData(isGlyph)
				}
				if (!preview) {
					contours.push((component as RectangleComponent).contour)
				} else {
					contours.push((component as RectangleComponent).preview)
				}
				break
			}
			case 'glyph-ellipse': {
				if (!(component as EllipseComponent).contour || !(component as EllipseComponent).contour.length || forceUpdate) {
					(component as EllipseComponent).updateData(isGlyph)
				}
				if (!preview) {
					contours.push((component as EllipseComponent).contour)
				} else {
					contours.push((component as EllipseComponent).preview)
				}
				break
			}
			case 'glyph': {
				const { ox, oy } = component as IGlyphComponent
				const glyph = (component as Component).value as unknown as ICustomGlyph
				if (!glyph._o || forceUpdate) {
					executeScript(glyph)
					glyph._o.getJoints().map((joint) => {
						joint.component = component as IGlyphComponent
					})
				}
				// executeScript(glyph)
				const contours1 = componentsToContours(glyph._o.components, options, { x: ox, y: oy }, isGlyph, preview, true)
				contours = contours.concat(contours1)
				break
			}
			default: {
				const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
				contours.push(contour)
				break
			}
		}
	})
	if (offset.x || offset.y) {
		if (preview) {
			const scale = 100 / (options.unitsPerEm as number)
			contours = R.clone(contours)
			for (let i = 0; i < contours.length; i++) {
				const contour = contours[i]
				for (let j = 0; j < contour.length; j++) {
					const path = contour[j]
					if (path.type === PathType.LINE) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
					} else if (path.type === PathType.QUADRATIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
						path.control.x += offset.x * scale
						path.control.y += offset.y * scale
					} else if (path.type === PathType.CUBIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
						path.control1.x += offset.x * scale
						path.control1.y += offset.y * scale
						path.control2.x += offset.x * scale
						path.control2.y += offset.y * scale
					}
				}
			}
		} else {
			const scale = 1
			contours = R.clone(contours)
			for (let i = 0; i < contours.length; i++) {
				const contour = contours[i]
				for (let j = 0; j < contour.length; j++) {
					const path = contour[j]
					if (path.type === PathType.LINE) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
					} else if (path.type === PathType.QUADRATIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
						path.control.x += offset.x * scale
						path.control.y -= offset.y * scale
					} else if (path.type === PathType.CUBIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
						path.control1.x += offset.x * scale
						path.control1.y -= offset.y * scale
						path.control2.x += offset.x * scale
						path.control2.y -= offset.y * scale
					}
				}
			}
		}
	}
	return contours
}

const componentsToContours2 = (components: Array<_Component>, offset: {
	x: number,
	y: number,
} = { x: 0, y: 0 }, isGlyph: boolean = false) => {
	let contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>> = []
	components.map((component) => {
		if (!component.usedInCharacter) return
		let { x, y, w, h, rotation, flipX, flipY } = component as IComponent
		switch (component.type) {
			case 'pen': {
				let transformed_points = transformPoints(((component as Component).value as unknown as IPenComponent).points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genPenContour(transformed_points);
				contours.push(contour)
				break
			}
			case 'polygon': {
				let transformed_points = transformPoints(((component as Component).value as unknown as IPolygonComponent).points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genPolygonContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'rectangle': {
				const rect = (component as Component).value as unknown as IRectangleComponent
				let transformed_points = transformPoints(getRectanglePoints(
					rect.width,
					rect.height,
					(component as IComponent).x,
					(component as IComponent).y,
				), {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genRectangleContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'ellipse': {
				const ellipse = (component as Component).value as unknown as IEllipseComponent
				let points = getEllipsePoints(
					ellipse.radiusX,
					ellipse.radiusY,
					1000,
					(component as IComponent).x + ellipse.radiusX,
					(component as IComponent).y + ellipse.radiusY,
				)
				const transformed_points = transformPoints(points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genEllipseContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'glyph-pen': {
				(component as PenComponent).updateData2()
				contours.push((component as PenComponent).contour2)
				break
			}
			case 'glyph-polygon': {
				(component as PolygonComponent).updateData2()
				contours.push((component as PolygonComponent).contour2)
				break
			}
			case 'glyph-rectangle': {
				(component as RectangleComponent).updateData2()
				contours.push((component as RectangleComponent).contour)
				break
			}
			case 'glyph-ellipse': {
				(component as EllipseComponent).updateData2()
				contours.push((component as EllipseComponent).contour)
				break
			}
			case 'glyph': {
				const { ox, oy } = component as IGlyphComponent
				const glyph = (component as Component).value as unknown as ICustomGlyph
				if (!glyph._o) {
					executeScript(glyph)
					glyph._o.getJoints().map((joint) => {
						joint.component = component as IGlyphComponent
					})
				}
				// executeScript(glyph)
				const contours1 = componentsToContours2(glyph._o.components, { x: ox, y: oy }, isGlyph)
				contours = contours.concat(contours1)
				break
			}
			default: {
				const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
				contours.push(contour)
				break
			}
		}
	})
	if (offset.x || offset.y) {
		const scale = 1
		contours = R.clone(contours)
		for (let i = 0; i < contours.length; i++) {
			const contour = contours[i]
			for (let j = 0; j < contour.length; j++) {
				const path = contour[j]
				if (path.type === PathType.LINE) {
					path.start.x += offset.x * scale
					path.start.y -= offset.y * scale
					path.end.x += offset.x * scale
					path.end.y -= offset.y * scale
				} else if (path.type === PathType.QUADRATIC_BEZIER) {
					path.start.x += offset.x * scale
					path.start.y -= offset.y * scale
					path.end.x += offset.x * scale
					path.end.y -= offset.y * scale
					path.control.x += offset.x * scale
					path.control.y -= offset.y * scale
				} else if (path.type === PathType.CUBIC_BEZIER) {
					path.start.x += offset.x * scale
					path.start.y -= offset.y * scale
					path.end.x += offset.x * scale
					path.end.y -= offset.y * scale
					path.control1.x += offset.x * scale
					path.control1.y -= offset.y * scale
					path.control2.x += offset.x * scale
					path.control2.y -= offset.y * scale
				}
		  }
		}
	}
	return contours
}

const genEllipseContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	let curves = fitCurve(points, 2)
	if (curves.length) {
		for (let i = 0; i < curves.length; i++) {
			const curve = curves[i]
			contour.push({
				type: PathType.CUBIC_BEZIER,
				start: {
					x: curve[0].x,
					y: curve[0].y,
				},
				end: {
					x: curve[3].x,
					y: curve[3].y,
				},
				control1: {
					x: curve[1].x,
					y: curve[1].y,
				},
				control2: {
					x: curve[2].x,
					y: curve[2].y,
				},
			})
		}
	}
	return contour
}

const genRectangleContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i++) {
		contour.push({
			type: PathType.LINE,
			start: {
				x: points[i].x,
				y: points[i].y,
			},
			end: {
				x: points[i + 1].x,
				y: points[i + 1].y,
			},
		})
	}
	return contour
}

const genPenContour = (points, fill: boolean = false) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i += 3) {
		if (i + 3 >= points.length) break
			contour.push({
				type: PathType.CUBIC_BEZIER,
				start: {
					x: points[i].x,
					y: points[i].y,
				},
				end: {
					x: points[i + 3].x,
					y: points[i + 3].y,
				},
				control1: {
					x: points[i + 1].x,
					y: points[i + 1].y,
				},
				control2: {
					x: points[i + 2].x,
					y: points[i + 2].y,
				},
				fill,
			})
	}
	return contour
}

const genPolygonContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i++) {
		contour.push({
			type: PathType.LINE,
			start: {
				x: points[i].x,
				y: points[i].y,
			},
			end: {
				x: points[i + 1].x,
				y: points[i + 1].y,
			},
		})
	}
	return contour
}

export {
	contoursToComponents,
	formatPoints,
	componentsToContours,
	componentsToContours2,
	genPenContour,
	genPolygonContour,
	genEllipseContour,
	genRectangleContour,
}