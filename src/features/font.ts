/**
 * fontManager生成的字体轮廓与fontEditor中的字体组件相互转换方法
 */
/**
 * convertor for contours generated by fontManager to components defined in fontEditor
 */

import { PathType } from '../fontManager'
import type {
	ILine,
	ICubicBezierCurve,
	IQuadraticBezierCurve,
} from '../fontManager'
import { genPenComponent } from '../fontEditor/tools/pen'
import type { IComponent, Component } from '../fontEditor/stores/files'
import { type IPoint as IPenPoint } from '../fontEditor/stores/pen'
import type { IPenComponent } from '../fontEditor/stores/files'
import { modifyComponentForCharacterFile, type IPolygonComponent, type IRectangleComponent } from '../fontEditor/stores/files'
import type { IEllipseComponent } from '../fontEditor/stores/files'
import { fitCurve, type IPoint } from '../features/fitCurve'
import { getEllipsePoints, getRectanglePoints, transformPoints } from '../utils/math'
import { genUUID, genLightId } from '../utils/string'
import { width } from '../fontEditor/stores/global'
import { ICustomGlyph, IGlyphComponent, executeScript, modifyComponentForGlyph, orderedListWithItemsForGlyph } from '../fontEditor/stores/glyph'
import { EllipseComponent } from '../fontEditor/programming/EllipseComponent'
import { RectangleComponent } from '../fontEditor/programming/RectangleComponent'
import { PenComponent } from '../fontEditor/programming/PenComponent'
import { PolygonComponent } from '../fontEditor/programming/PolygonComponent'
import { computeCoords } from '../fontEditor/canvas/canvas'
import { executeScript as executeScript_playground } from '../fontEditor/stores/playground'
import { executeScript as executeScript_advancedEdit } from '../fontEditor/stores/advancedEdit'

const contoursToComponents = (contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
}) => {
	const components = contours.map((contour) => {
		const points: Array<IPenPoint> = []
		for (let i = 0; i < contour.length; i++) {
			const path = contour[i]
			if (i === 0) {
				points.push({
					uuid: genLightId(), // 使用轻量级ID
					x: path.start.x,
					y: path.start.y,
					type: 'anchor',
					origin: null,
					isShow: true,
				})
			}
			switch (path.type) {
				case PathType.LINE: {
					const control1 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.start.x,
						y: path.start.y,
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.end.x,
						y: path.end.y,
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
				case PathType.QUADRATIC_BEZIER: {
					const control1 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.start.x + 2 / 3 * (path.control.x - path.start.x),
						y: path.start.y + 2 / 3 * (path.control.y - path.start.y),
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.end.x + 2 / 3 * (path.control.x - path.end.x),
						y: path.end.y + 2 / 3 * (path.control.y - path.end.y),
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
				case PathType.CUBIC_BEZIER: {
					const control1 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.control1.x,
						y: path.control1.y,
						type: 'control',
						origin: points[points.length - 1].uuid,
						isShow: true,
					}
					const anchor2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.end.x,
						y: path.end.y,
						type: 'anchor',
						origin: null,
						isShow: true,
					}
					const control2 = {
						uuid: genLightId(), // 使用轻量级ID
						x: path.control2.x,
						y: path.control2.y,
						type: 'control',
						origin: anchor2.uuid,
						isShow: true,
					}
					points.push(control1, control2, anchor2)
					break
				}
			}
		}
		if (points.length && (points[points.length - 1].x !== points[0].x || points[points.length - 1].x !== points[0].y)) {
			points.push({
				uuid: genLightId(), // 使用轻量级ID
				x: points[points.length - 1].x,
				y: points[points.length - 1].y,
				type: 'control',
				origin: points[points.length - 1].uuid,
				isShow: true,
			})
			points.push({
				uuid: genLightId(), // 使用轻量级ID
				x: points[0].x,
				y: points[0].y,
				type: 'control',
				origin: points[0].uuid,
				isShow: true,
			})
			points.push({
				uuid: genLightId(), // 使用轻量级ID
				x: points[0].x,
				y: points[0].y,
				type: 'anchor',
				origin: points[0].uuid,
				isShow: true,
			})
		}
		return genPenComponent(formatPoints(points, options, 0) as Array<IPenPoint>, true) as unknown as IComponent
	})
	return components
}

const formatPoints = (points: Array<IPenPoint | IPoint>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
}, type: number) => {
	const { unitsPerEm, descender, advanceWidth } = options
	if (type === 0) {
		const scale = 1//width.value / unitsPerEm
		return points.map((point) => {
			let x = point.x + (unitsPerEm - advanceWidth) / 2
			//let y = point.y + unitsPerEm - ascender
			let y = unitsPerEm - point.y
			y = y + descender
			x *= scale
			y *= scale
			return {
				...point,
				x, y
			}
		})
	} else if (type === 1) {
		const scale = 1//unitsPerEm / width.value
		return points.map((point) => {
			let x = point.x * scale
			let y = point.y * scale
			x -= (unitsPerEm - advanceWidth) / 2
			y = y - descender
			y = unitsPerEm - y
			return {
				...point,
				x, y
			}
		})
	}
	return points
}

type _Component = Component | EllipseComponent | RectangleComponent | PenComponent | PolygonComponent

const translate = (p, offset) => {
	return {
		x: p.x + offset.x,
		y: p.y + offset.y,
	}
}

const componentsToContours = (components: Array<_Component>, options: {
	unitsPerEm: number,
	descender: number,
	advanceWidth: number,
	grid?: any,
	useSkeletonGrid?: boolean,
	playground?: boolean,
	advancedEdit?: boolean,
}, offset: {
	x: number,
	y: number,
} = { x: 0, y: 0 }, isGlyph: boolean = false, preview: boolean = true, forceUpdate: boolean = false) => {
	//-------
	// forceUpdate = true
	//-------
	if (options && !options.advanceWidth) {
		options.advanceWidth = options.unitsPerEm
	}
	const useSkeletonGrid = (options && options.useSkeletonGrid) || false
	let contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>> = []
	components.map((component) => {
		if (!component?.usedInCharacter) return
		let { x, y, w, h, rotation, flipX, flipY } = component as IComponent
		//x && (x += offset.x)
		//y && (y += offset.y)
		switch (component.type) {
			case 'pen': {
				if (!((component as Component).value as unknown as IPenComponent).contour || forceUpdate) {
					let transformed_points = transformPoints(((component as Component).value as unknown as IPenComponent).points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					transformed_points = transformed_points.map((point) => {
						const p = translate(point, offset)
						if (options.grid && !useSkeletonGrid) {
							return computeCoords(options.grid, p)
						} else {
							return p
						}
					})
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genPenContour(contour_points)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genPenContour(preview_points);

					((component as Component).value as unknown as IPenComponent).preview = preview_contour;
					((component as Component).value as unknown as IPenComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IPenComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IPenComponent).preview)
				}
				break
			}
			case 'polygon': {
				if (!((component as Component).value as unknown as IPolygonComponent).contour || forceUpdate) {
					let transformed_points = transformPoints(((component as Component).value as unknown as IPolygonComponent).points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					transformed_points = transformed_points.map((point) => {
						const p = translate(point, offset)
						if (options.grid && !useSkeletonGrid) {
							return computeCoords(options.grid, p)
						} else {
							return p
						}
					})
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genPolygonContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genPolygonContour(preview_points);

					((component as Component).value as unknown as IPolygonComponent).preview = preview_contour;
					((component as Component).value as unknown as IPolygonComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IPolygonComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IPolygonComponent).preview)
				}
				break
			}
			case 'rectangle': {
				if (!((component as Component).value as unknown as IRectangleComponent).contour || forceUpdate) {
					const rect = (component as Component).value as unknown as IRectangleComponent
					let transformed_points = transformPoints(getRectanglePoints(
						rect.width,
						rect.height,
						(component as IComponent).x,
						(component as IComponent).y,
					), {
						x, y, w, h, rotation, flipX, flipY,
					})
					transformed_points = transformed_points.map((point) => {
						const p = translate(point, offset)
						if (options.grid && !useSkeletonGrid) {
							return computeCoords(options.grid, p)
						} else {
							return p
						}
					})
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genRectangleContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genRectangleContour(preview_points);

					((component as Component).value as unknown as IRectangleComponent).preview = preview_contour;
					((component as Component).value as unknown as IRectangleComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IRectangleComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IRectangleComponent).preview)
				}
				break
			}
			case 'ellipse': {
				if (!((component as Component).value as unknown as IRectangleComponent).contour || forceUpdate) {
					const ellipse = (component as Component).value as unknown as IEllipseComponent
					let points = getEllipsePoints(
						ellipse.radiusX,
						ellipse.radiusY,
						1000,
						(component as IComponent).x + ellipse.radiusX,
						(component as IComponent).y + ellipse.radiusY,
					)
					let transformed_points = transformPoints(points, {
						x, y, w, h, rotation, flipX, flipY,
					})
					transformed_points = transformed_points.map((point) => {
						const p = translate(point, offset)
						if (options.grid && !useSkeletonGrid) {
							return computeCoords(options.grid, p)
						} else {
							return p
						}
					})
					const contour_points = formatPoints(transformed_points, options, 1)
					const contour = genEllipseContour(contour_points)
					contours.push(contour)

					const scale = 100 / (options.unitsPerEm as number)
					const preview_points = transformed_points.map((point) => {
						return Object.assign({}, point, {
							x: point.x * scale,
							y: point.y * scale,
						})
					})
					const preview_contour = genEllipseContour(preview_points);

					((component as Component).value as unknown as IRectangleComponent).preview = preview_contour;
					((component as Component).value as unknown as IRectangleComponent).contour = contour
				}
				if (!preview) {
					contours.push(((component as Component).value as unknown as IRectangleComponent).contour)
				} else {
					contours.push(((component as Component).value as unknown as IRectangleComponent).preview)
				}
				break
			}
			case 'glyph-pen': {
				if (!(component as PenComponent).contour || !(component as PenComponent).contour.length || forceUpdate) {
					if (!options.grid || useSkeletonGrid) {
						// 不使用布局调整或使用骨架布局调整的情况下，使用给定组件本身的数据，不进行布局调整。
						// 注意如果使用骨架布局调整，给定的组件是根据调整后骨架计算出的组件，所以不用再次进行调整
						(component as PenComponent).updateData(isGlyph, offset)
					} else {
						(component as PenComponent).updateData(isGlyph, offset, options.grid)
					}
				}
				if (!preview) {
					contours.push((component as PenComponent).contour)
				} else {
					contours.push((component as PenComponent).preview)
				}
				break
			}
			case 'glyph-polygon': {
				if (!(component as PolygonComponent).contour || !(component as PolygonComponent).contour.length || forceUpdate) {
					if (!options.grid || useSkeletonGrid) {
						// 不使用布局调整或使用骨架布局调整的情况下，使用给定组件本身的数据，不进行布局调整。
						// 注意如果使用骨架布局调整，给定的组件是根据调整后骨架计算出的组件，所以不用再次进行调整
						(component as PolygonComponent).updateData(isGlyph, offset)
					} else {
						(component as PolygonComponent).updateData(isGlyph, offset, options.grid)
					}
				}
				if (!preview) {
					contours.push((component as PolygonComponent).contour)
				} else {
					contours.push((component as PolygonComponent).preview)
				}
				break
			}
			case 'glyph-rectangle': {
				if (!(component as RectangleComponent).contour || !(component as RectangleComponent).contour.length || forceUpdate) {
					if (!options.grid || useSkeletonGrid) {
						// 不使用布局调整或使用骨架布局调整的情况下，使用给定组件本身的数据，不进行布局调整。
						// 注意如果使用骨架布局调整，给定的组件是根据调整后骨架计算出的组件，所以不用再次进行调整
						(component as RectangleComponent).updateData(isGlyph, offset)
					} else {
						(component as RectangleComponent).updateData(isGlyph, offset, options.grid)
					}
				}
				if (!preview) {
					contours.push((component as RectangleComponent).contour)
				} else {
					contours.push((component as RectangleComponent).preview)
				}
				break
			}
			case 'glyph-ellipse': {
				if (!(component as EllipseComponent).contour || !(component as EllipseComponent).contour.length || forceUpdate) {
					if (!options.grid || useSkeletonGrid) {
						// 不使用布局调整或使用骨架布局调整的情况下，使用给定组件本身的数据，不进行布局调整。
						// 注意如果使用骨架布局调整，给定的组件是根据调整后骨架计算出的组件，所以不用再次进行调整
						(component as EllipseComponent).updateData(isGlyph, offset)
					} else {
						(component as EllipseComponent).updateData(isGlyph, offset, options.grid)
					}
				}
				if (!preview) {
					contours.push((component as EllipseComponent).contour)
				} else {
					contours.push((component as EllipseComponent).preview)
				}
				break
			}
			case 'glyph': {
				const { ox, oy } = component as IGlyphComponent
				const glyph = (component as Component).value as unknown as ICustomGlyph
				if (!glyph._o || forceUpdate) {
					if (options && options.playground) {
						executeScript_playground(glyph)
					} else if (options && options.advancedEdit) {
						executeScript_advancedEdit(glyph)
					} else {
						executeScript(glyph)
					}
					// glyph._o.getJoints().map((joint) => {
					// 	joint.component = component as IGlyphComponent
					// })
				}
				// executeScript(glyph)
				if (useSkeletonGrid && options.grid && glyph._o?.getSkeleton) {
					// 使用骨架布局调整的情况下，对于非字形实例本身组件，也就是非使用脚本提交的组件，正常计算
					// 对于字形实例本身实用脚本创建的组件，先计算调整后骨架，再依据调整后的骨架计算最终组件
					const _skeleton = glyph._o.getSkeleton()
					const skeleton = {}
					const keys = Object.keys(_skeleton)
					for (let i = 0; i < keys.length; i++) {
						const key = keys[i]
						const _joint = _skeleton[key]
						const joint = {
							x: _joint.x + offset.x + ox,
							y: _joint.y + offset.y + oy,
						}
						skeleton[key] = computeCoords(options.grid, joint)
					}
					const components1 = glyph._o.getComponentsBySkeleton(skeleton)
					const components2 = orderedListWithItemsForGlyph(glyph)
					const contours1 = componentsToContours(components1.concat(components2), options, { x: 0, y: 0 }, isGlyph, preview, true)
					// const contours1 = componentsToContours(components1.concat(components2), options, { x: offset.x + ox, y: offset.y + oy }, isGlyph, preview, true)
					contours = contours.concat(contours1)
				} else {
					// 不使用骨架布局调整
					const contours1 = componentsToContours(glyph._o.components, options, { x: offset.x + ox, y: offset.y + oy }, isGlyph, preview, true)
					contours = contours.concat(contours1)
				}
				break
			}
			default: {
				const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
				contours.push(contour)
				break
			}
		}
	})
	// if (offset.x || offset.y) {
	// 	if (preview) {
	// 		const scale = 100 / (options.unitsPerEm as number)
	// 		contours = R.clone(contours)
	// 		for (let i = 0; i < contours.length; i++) {
	// 			const contour = contours[i]
	// 			for (let j = 0; j < contour.length; j++) {
	// 				const path = contour[j]
	// 				if (path.type === PathType.LINE) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y += offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y += offset.y * scale
	// 				} else if (path.type === PathType.QUADRATIC_BEZIER) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y += offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y += offset.y * scale
	// 					path.control.x += offset.x * scale
	// 					path.control.y += offset.y * scale
	// 				} else if (path.type === PathType.CUBIC_BEZIER) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y += offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y += offset.y * scale
	// 					path.control1.x += offset.x * scale
	// 					path.control1.y += offset.y * scale
	// 					path.control2.x += offset.x * scale
	// 					path.control2.y += offset.y * scale
	// 				}
	// 			}
	// 		}
	// 	} else {
	// 		const scale = 1
	// 		contours = R.clone(contours)
	// 		for (let i = 0; i < contours.length; i++) {
	// 			const contour = contours[i]
	// 			for (let j = 0; j < contour.length; j++) {
	// 				const path = contour[j]
	// 				if (path.type === PathType.LINE) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y -= offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y -= offset.y * scale
	// 				} else if (path.type === PathType.QUADRATIC_BEZIER) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y -= offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y -= offset.y * scale
	// 					path.control.x += offset.x * scale
	// 					path.control.y -= offset.y * scale
	// 				} else if (path.type === PathType.CUBIC_BEZIER) {
	// 					path.start.x += offset.x * scale
	// 					path.start.y -= offset.y * scale
	// 					path.end.x += offset.x * scale
	// 					path.end.y -= offset.y * scale
	// 					path.control1.x += offset.x * scale
	// 					path.control1.y -= offset.y * scale
	// 					path.control2.x += offset.x * scale
	// 					path.control2.y -= offset.y * scale
	// 				}
	// 			}
	// 		}
	// 	}
	// }
	return contours
}

const componentsToContours2 = (components: Array<_Component>, offset: {
	x: number,
	y: number,
} = { x: 0, y: 0 }, isGlyph: boolean = false, contour_type: number = 0) => {
	let contours: Array<Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve>> = []
	components.map((component) => {
		if (!component.usedInCharacter) return
		let { x, y, w, h, rotation, flipX, flipY } = component as IComponent
		switch (component.type) {
			case 'pen': {
				let transformed_points = transformPoints(((component as Component).value as unknown as IPenComponent).points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genPenContour(transformed_points);
				contours.push(contour)
				break
			}
			case 'polygon': {
				let transformed_points = transformPoints(((component as Component).value as unknown as IPolygonComponent).points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genPolygonContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'rectangle': {
				const rect = (component as Component).value as unknown as IRectangleComponent
				let transformed_points = transformPoints(getRectanglePoints(
					rect.width,
					rect.height,
					(component as IComponent).x,
					(component as IComponent).y,
				), {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genRectangleContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'ellipse': {
				const ellipse = (component as Component).value as unknown as IEllipseComponent
				let points = getEllipsePoints(
					ellipse.radiusX,
					ellipse.radiusY,
					1000,
					(component as IComponent).x + ellipse.radiusX,
					(component as IComponent).y + ellipse.radiusY,
				)
				const transformed_points = transformPoints(points, {
					x, y, w, h, rotation, flipX, flipY,
				})
				const contour = genEllipseContour(transformed_points)
				contours.push(contour)
				break
			}
			case 'glyph-pen': {
				(component as PenComponent).updateData2()
				contours.push((component as PenComponent).contour2)
				break
			}
			case 'glyph-polygon': {
				(component as PolygonComponent).updateData2()
				contours.push((component as PolygonComponent).contour2)
				break
			}
			case 'glyph-rectangle': {
				(component as RectangleComponent).updateData2()
				contours.push((component as RectangleComponent).contour)
				break
			}
			case 'glyph-ellipse': {
				(component as EllipseComponent).updateData2()
				contours.push((component as EllipseComponent).contour)
				break
			}
			case 'glyph': {
				const { ox, oy } = component as IGlyphComponent
				const glyph = (component as Component).value as unknown as ICustomGlyph
				if (!glyph._o) {
					executeScript(glyph)
					// glyph._o.getJoints().map((joint) => {
					// 	joint.component = component as IGlyphComponent
					// })
				}
				// executeScript(glyph)
				const contours1 = componentsToContours2(glyph._o.components, { x: ox, y: oy }, isGlyph, contour_type)
				contours = contours.concat(contours1)
				break
			}
			default: {
				const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
				contours.push(contour)
				break
			}
		}
	})
	if (offset.x || offset.y) {
		if (contour_type === 0) {
			// 生成导出字体最终的轮廓（坐标起始点为字体baseline），y坐标越大，对应点的位置越高
			const scale = 1
			for (let i = 0; i < contours.length; i++) {
				const contour = contours[i]
				for (let j = 0; j < contour.length; j++) {
					const path = contour[j]
					if (path.type === PathType.LINE) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
					} else if (path.type === PathType.QUADRATIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
						path.control.x += offset.x * scale
						path.control.y -= offset.y * scale
					} else if (path.type === PathType.CUBIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y -= offset.y * scale
						path.end.x += offset.x * scale
						path.end.y -= offset.y * scale
						path.control1.x += offset.x * scale
						path.control1.y -= offset.y * scale
						path.control2.x += offset.x * scale
						path.control2.y -= offset.y * scale
					}
				}
			}
		} else if (contour_type === 1) {
			// 生成程序中展示所用的轮廓，原点位于canvas左上角，y坐标越大，对应点的位置越往下
			const scale = 1
			for (let i = 0; i < contours.length; i++) {
				const contour = contours[i]
				for (let j = 0; j < contour.length; j++) {
					const path = contour[j]
					if (path.type === PathType.LINE) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
					} else if (path.type === PathType.QUADRATIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
						path.control.x += offset.x * scale
						path.control.y -= offset.y * scale
					} else if (path.type === PathType.CUBIC_BEZIER) {
						path.start.x += offset.x * scale
						path.start.y += offset.y * scale
						path.end.x += offset.x * scale
						path.end.y += offset.y * scale
						path.control1.x += offset.x * scale
						path.control1.y += offset.y * scale
						path.control2.x += offset.x * scale
						path.control2.y += offset.y * scale
					}
				}
			}
		}
	}
	return contours
}

const genEllipseContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	let curves = fitCurve(points, 2)
	if (curves.length) {
		for (let i = 0; i < curves.length; i++) {
			const curve = curves[i]
			contour.push({
				type: PathType.CUBIC_BEZIER,
				start: {
					x: curve[0].x,
					y: curve[0].y,
				},
				end: {
					x: curve[3].x,
					y: curve[3].y,
				},
				control1: {
					x: curve[1].x,
					y: curve[1].y,
				},
				control2: {
					x: curve[2].x,
					y: curve[2].y,
				},
			})
		}
	}
	return contour
}

const genRectangleContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i++) {
		contour.push({
			type: PathType.LINE,
			start: {
				x: points[i].x,
				y: points[i].y,
			},
			end: {
				x: points[i + 1].x,
				y: points[i + 1].y,
			},
		})
	}
	return contour
}

const genPenContour = (points, fill: boolean = false) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i += 3) {
		if (i + 3 >= points.length) break
			contour.push({
				type: PathType.CUBIC_BEZIER,
				start: {
					x: points[i].x,
					y: points[i].y,
				},
				end: {
					x: points[i + 3].x,
					y: points[i + 3].y,
				},
				control1: {
					x: points[i + 1].x,
					y: points[i + 1].y,
				},
				control2: {
					x: points[i + 2].x,
					y: points[i + 2].y,
				},
				fill,
			})
	}
	return contour
}

const genPolygonContour = (points) => {
	const contour: Array<ILine | IQuadraticBezierCurve | ICubicBezierCurve> = []
	for (let i = 0; i < points.length - 1; i++) {
		contour.push({
			type: PathType.LINE,
			start: {
				x: points[i].x,
				y: points[i].y,
			},
			end: {
				x: points[i + 1].x,
				y: points[i + 1].y,
			},
		})
	}
	return contour
}

export {
	contoursToComponents,
	formatPoints,
	componentsToContours,
	componentsToContours2,
	genPenContour,
	genPolygonContour,
	genEllipseContour,
	genRectangleContour,
	translate,
}